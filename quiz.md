# Тести для самоперевірки

## Тест 1: Основи алгоритмів

### Питання 1
Яка часова складність бульбашкового сортування у найгіршому випадку?
- A) O(n)
- B) O(n log n)
- C) O(n²)
- D) O(log n)

**Відповідь:** C

### Питання 2
Який з алгоритмів є стабільним?
- A) Бульбашкове сортування
- B) Сортування вибором
- C) Обидва
- D) Жоден

**Відповідь:** A

### Питання 3
Скільки порівнянь виконає bubble sort для відсортованого масиву з оптимізацією?
- A) n²
- B) n
- C) n-1
- D) 0

**Відповідь:** C

## Тест 2: Практичні задачі

### Задача 1
Який буде масив після першого проходу bubble sort?
```
Початковий: [4, 2, 7, 1, 3]
```
**Відповідь:** [2, 4, 1, 3, 7]

### Задача 2
Скільки обмінів виконає selection sort для масиву [3, 1, 4, 2]?
**Відповідь:** 2

### Задача 3
Яка просторова складність merge sort?
**Відповідь:** O(n)

## Тест 3: Кейси

### Кейс 1
У вас є майже відсортований масив з 1000 елементів. Який алгоритм буде найефективнішим?

**Аналіз:**
- Bubble sort з оптимізацією: O(n) у кращому випадку
- Selection sort: завжди O(n²)
- Merge sort: завжди O(n log n)

**Відповідь:** Оптимізований bubble sort

### Кейс 2
Потрібно відсортувати масив з 10 мільйонів елементів. Який алгоритм обрати?

**Відповідь:** Merge sort (O(n log n) краще за O(n²) для великих n)

## Питання для роздумів

1. Чому bubble sort називається "бульбашковим"?
2. В яких випадках простіші алгоритми можуть бути кращими за складніші?
3. Як можна покращити базові алгоритми сортування?

## Практичне завдання

Напишіть функцію, яка визначає, чи є масив відсортованим:

```python
def is_sorted(arr):
    # Ваш код
    pass

# Тести
print(is_sorted([1, 2, 3, 4]))  # True
print(is_sorted([1, 3, 2, 4]))  # False
print(is_sorted([]))            # True
```