# Аналіз складності алгоритмів сортування

## Що таке складність алгоритму?

Складність алгоритму - це міра того, скільки ресурсів (часу або пам'яті) потрібно алгоритму для виконання залежно від розміру вхідних даних.

### Типи складності

1. **Часова складність** - скільки часу потрібно для виконання
2. **Просторова складність** - скільки додаткової пам'яті потрібно

## Big O нотація

Big O описує верхню межу складності алгоритму - найгірший випадок.

### Основні класи складності

- **O(1)** - константна (не залежить від розміру)
- **O(log n)** - логарифмічна
- **O(n)** - лінійна
- **O(n log n)** - лінійно-логарифмічна
- **O(n²)** - квадратична
- **O(2ⁿ)** - експоненційна

## Порівняння алгоритмів сортування

### Таблиця складності

| Алгоритм | Найкращий | Середній | Найгірший | Пам'ять | Стабільний |
|----------|-----------|----------|-----------|---------|------------|
| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | Так |
| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | Ні |
| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | Так |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | Так |
| Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) | Ні |
| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | Ні |

### Детальний аналіз

#### Bubble Sort
```
Кількість порівнянь: (n-1) + (n-2) + ... + 1 = n(n-1)/2
Часова складність: O(n²)
```

**Найкращий випадок (O(n))**: Масив вже відсортований, з оптимізацією алгоритм зупиняється після першого проходу.

**Найгірший випадок (O(n²))**: Масив відсортований у зворотному порядку.

#### Selection Sort
```
Кількість порівнянь: (n-1) + (n-2) + ... + 1 = n(n-1)/2
Кількість обмінів: максимум n-1
Часова складність: O(n²)
```

**Особливість**: Складність однакова для всіх випадків, бо алгоритм завжди виконує всі порівняння.

#### Merge Sort
```
Глибина рекурсії: log₂ n
Робота на кожному рівні: O(n)
Загальна складність: O(n log n)
```

**Переваги**: Гарантована складність O(n log n) у всіх випадках.

**Недоліки**: Потребує додаткову пам'ять O(n).

## Візуальне порівняння

### Графік росту складності

```
Час виконання
    |
n²  |                    ....''''
    |                ..''    
    |            ..''        Selection/Bubble
    |        ..''            
n log n |    .'''''''''''''  Merge Sort
    | ..'''''
n   |.'                      Linear (для порівняння)
    |________________________
    10   100   1000   10000  Розмір масиву
```

### Практичні приклади часу виконання

Для масиву з 10,000 елементів на типовому комп'ютері:

| Алгоритм | Приблизний час |
|----------|----------------|
| Bubble Sort | ~1 секунда |
| Selection Sort | ~0.5 секунди |
| Merge Sort | ~0.01 секунди |
| Quick Sort | ~0.008 секунди |

## Як вибрати алгоритм?

### Рекомендації за розміром даних

- **< 10 елементів**: Будь-який алгоритм (навіть Bubble Sort)
- **10-100 елементів**: Insertion Sort або Selection Sort
- **100-1000 елементів**: Shell Sort або Quick Sort
- **> 1000 елементів**: Merge Sort, Quick Sort або Heap Sort

### Рекомендації за типом даних

- **Майже відсортовані**: Insertion Sort або Bubble Sort з оптимізацією
- **Випадкові**: Quick Sort або Merge Sort
- **Багато однакових елементів**: Merge Sort (стабільний)
- **Обмежена пам'ять**: Heap Sort або Quick Sort

## Стабільність алгоритмів

**Стабільний алгоритм** зберігає відносний порядок елементів з однаковими ключами.

### Приклад
```
Початковий масив: [(2, 'a'), (1, 'b'), (2, 'c')]
                    ↑ ключ   ↑ значення

Після стабільного сортування: [(1, 'b'), (2, 'a'), (2, 'c')]
                                           ↑ порядок збережено

Після нестабільного: [(1, 'b'), (2, 'c'), (2, 'a')]
                                  ↑ порядок змінено
```

## Адаптивність

**Адаптивний алгоритм** працює швидше на частково відсортованих даних.

- **Адаптивні**: Bubble Sort, Insertion Sort
- **Неадаптивні**: Selection Sort, Heap Sort, Merge Sort

## Практичні поради

1. **Для навчання**: почніть з Bubble Sort
2. **Для малих масивів**: Insertion Sort
3. **Для загального використання**: Quick Sort або Merge Sort
4. **Для гарантованої швидкості**: Merge Sort
5. **Коли важлива стабільність**: Merge Sort або Insertion Sort
6. **Коли обмежена пам'ять**: Quick Sort або Heap Sort

## Висновок

Не існує "найкращого" алгоритму сортування для всіх випадків. Вибір залежить від:
- Розміру даних
- Характеру даних (випадкові, частково відсортовані)
- Обмежень пам'яті
- Потреби в стабільності
- Простоти реалізації

Розуміння складності алгоритмів допоможе вам приймати правильні рішення при виборі алгоритму для конкретної задачі.